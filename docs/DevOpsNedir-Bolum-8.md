#  BakÄ±ÅŸ AÃ§Ä±nÄ±zÄ± DeÄŸiÅŸtirerek BakÄ±n | DevOps Nedir ? 

Her yazÄ±lÄ±m geliÅŸtiricinin kariyerinde bir an gelir ki anlar: YazÄ±lÄ±m tasarÄ±mÄ±, sadece klavyede kod dÃ¶ÅŸemekten ibaret deÄŸildir. Ã–zellikle DevOps kÃ¼ltÃ¼rÃ¼ sahneye Ã§Ä±ktÄ±ÄŸÄ±ndan beri, geliÅŸtirme ve operasyon el ele verip bir yazÄ±lÄ±m projesini uÃ§tan uca dÃ¼ÅŸÃ¼nmek zorundadÄ±r. Bu makalede, yeni baÅŸlayanlardan kÄ±demli mÃ¼hendislere kadar herkesin yÃ¼zÃ¼nÃ¼ gÃ¼ldÃ¼recek (belki yer yer acÄ± acÄ± gÃ¼ldÃ¼recek ğŸ˜…) bir Ã¼slupla, yazÄ±lÄ±m ekiplerinin tasarÄ±m aÅŸamasÄ±nda DevOps ilkelerini nasÄ±l benimseyebileceÄŸini inceleyeceÄŸiz. HazÄ±rsanÄ±z kahvenizi kapÄ±n, Ã§Ã¼nkÃ¼ birazdan kod yazmaktan fazlasÄ±nÄ±n neden bu kadar Ã¶nemli olduÄŸunu hem konuÅŸacaÄŸÄ±z hem de birlikte tebessÃ¼m edeceÄŸiz.

DevOpsâ€™u benimsemek, her bir kiÅŸiye, sÃ¼rece ve Ã¼rÃ¼ne DevOpsâ€™un temel felsefelerini aÅŸÄ±lamaya yÃ¶nelik bir taahhÃ¼ttÃ¼r. Ekibinizin Ã¼rettiÄŸi yazÄ±lÄ±m, birÃ§ok aÃ§Ä±dan ekibinizin deÄŸerlerinin ve ilkelerinin bir yansÄ±masÄ±dÄ±r. EÄŸer yazÄ±lÄ±mÄ±nÄ±z bu metodolojiyi yansÄ±tmÄ±yorsa, ne metodoloji ne de teknolojiniz iÅŸe yarayacaktÄ±r.

Bir Ã¼rÃ¼n ekibinin yaptÄ±ÄŸÄ± en bÃ¼yÃ¼k hatalardan biri, mÃ¼hendisliÄŸi tasarÄ±m sÃ¼recine Ã§ok geÃ§ dahil etmektir. ÃœrÃ¼nÃ¼nÃ¼zden herkesin haberdar olduÄŸundan, temel iÅŸ hedeflerinin anlaÅŸÄ±ldÄ±ÄŸÄ±ndan ve planlama sÃ¼recine dahil edildiÄŸinizden (ya da dahil olmaya teÅŸvik edildiÄŸinizden) zaten emin oldunuz. MeslektaÅŸlarÄ±nÄ±z beyin fÄ±rtÄ±nasÄ± sÃ¼recine katÄ±ldÄ±, Ã¶neriler sundu ve hangi Ã¶zelliklerin Ã¼rÃ¼nÃ¼n baÅŸarÄ±sÄ± aÃ§Ä±sÄ±ndan en kritik olduÄŸuna dair ortak bir anlayÄ±ÅŸa vardÄ±.

Bu bilgi paylaÅŸÄ±mÄ± sistemin tasarÄ±mÄ± baÅŸladÄ±ÄŸÄ±nda durmamalÄ±dÄ±r. Evet, kararlar alÄ±nmalÄ±dÄ±r ve bazen ortalÄ±kta Ã§ok fazla â€œaÅŸÃ§Ä±â€ varmÄ±ÅŸ gibi hissedebilirsiniz. Her kararda demokratik bir oylama yapmanÄ±zÄ± Ã¶nermiyorum. HiyerarÅŸi, mÃ¼hendislik ekiplerinde genellikle kritik bir rol oynar ve liderlik, tÃ¼m seÃ§enekler masaya yatÄ±rÄ±ldÄ±ÄŸÄ±nda net kararlar alabilmelidir.

Ancak burada Ã¶nemli olan ÅŸu: TÃ¼m seÃ§enekler masaya yatÄ±rÄ±ldÄ±ÄŸÄ±nda. TÃ¼m seÃ§enekleri ortaya koymak, herkesin sÃ¼rece dahil olmasÄ±nÄ± gerektirir. Planlama sÃ¼recinde oluÅŸturduÄŸunuz ivme, tasarÄ±m sÃ¼recinde de devam ettirilmelidir.

## DevOps ile yazÄ±lÄ±m tasarÄ±mÄ± neden sadece â€œkod yazmakâ€ deÄŸildir

YazÄ±lÄ±m geliÅŸtirme dÃ¼nyasÄ±na yeni adÄ±m atanlar iÃ§in tasarÄ±m Ã§oÄŸu zaman arka planda kalan bir gÃ¶lgedir; esas iÅŸ kod yazmaktÄ±r, deÄŸil mi? AslÄ±nda yanlÄ±ÅŸ! Ä°yi bir yazÄ±lÄ±m tasarÄ±mÄ±, hikÃ¢yenin tamamÄ±dÄ±r ve kod sadece bu hikÃ¢yenin cÃ¼mlelerinden biridir. NasÄ±l ki bir roman sadece birkaÃ§ cÃ¼mleden ibaret deÄŸilse, yazÄ±lÄ±m geliÅŸtirme de sadece kod satÄ±rlarÄ±ndan ibaret deÄŸildir. Bir Ã¶zelliÄŸi tasarlarken, onu nasÄ±l inÅŸa edeceÄŸimiz kadar neden ve hangi baÄŸlamda inÅŸa ettiÄŸimiz de Ã¶nemlidir.

DevOps bakÄ±ÅŸ aÃ§Ä±sÄ±yla dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼mÃ¼zde, daha kodun ilk satÄ±rÄ±nÄ± yazmadan planlama, mimari, altyapÄ± ve operasyon boyutlarÄ±nÄ± masaya yatÄ±rÄ±rÄ±z. Kodun Ã§alÄ±ÅŸacaÄŸÄ± ortamÄ±, yaÅŸayacaÄŸÄ± kullanÄ±cÄ± senaryolarÄ±nÄ±, karÅŸÄ±laÅŸacaÄŸÄ± yÃ¼kÃ¼ Ã¶ngÃ¶rmek tasarÄ±m sÃ¼recinin parÃ§asÄ±dÄ±r. KÄ±sacasÄ±, yazÄ±lÄ±m tasarÄ±mÄ± bir ekip sporu gibidir: Kodcular, testÃ§iler, operasyoncular herkes aynÄ± oyun planÄ±na gÃ¶re hareket etmelidir. Aksi halde, geliÅŸtirdiÄŸiniz uygulama geliÅŸtirici makinesinde sorunsuz Ã§alÄ±ÅŸÄ±p sunucuda tuhaf dramalara yol aÃ§abilir (â€œBende Ã§alÄ±ÅŸÄ±yordu, sunucuda neden Ã§alÄ±ÅŸmÄ±yor?!â€ diye baÅŸlayan cÃ¼mleler tanÄ±dÄ±k geldi mi? ğŸ˜‰). Ä°ÅŸte bu yÃ¼zden, DevOps ile tasarÄ±m yapmak demek, daha en baÅŸÄ±ndan itibaren her adÄ±mÄ± ortak akÄ±lla ve geniÅŸ bir vizyonla planlamak demektir.

YazÄ±lÄ±mda mimari, bir sistemin yÃ¼ksek dÃ¼zeyde yapÄ±sÄ±nÄ± tasarlamayÄ± ifade eder. Bu yalnÄ±zca gerÃ§ek tasarÄ±mÄ± deÄŸil, aynÄ± zamanda mimari dokÃ¼mantasyonu da kapsar bu, yazÄ±lÄ±m sistemlerinde sÄ±klÄ±kla eksik olan bir kalitedir. Bunu tÃ¼m yazÄ±lÄ±m Ã¼rÃ¼nÃ¼nÃ¼z iÃ§in bir plan gibi dÃ¼ÅŸÃ¼nÃ¼n; her bir parÃ§anÄ±n nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±nÄ± ve birbirleriyle nasÄ±l etkileÅŸimde bulunacaÄŸÄ±nÄ± gÃ¶sterir.

YÃ¼ksek dÃ¼zey bir tasarÄ±m Ã¼zerinde Ã§alÄ±ÅŸÄ±rken, saÄŸlam bir Ã§erÃ§eve oluÅŸturmak iÃ§in dikkate alÄ±nmasÄ± gereken onlarca konu vardÄ±r. TÃ¼m bu konularla baÅŸa Ã§Ä±kmak, sadece bir Ã¼rÃ¼n yÃ¶neticisinin yeteneklerini deÄŸil, aynÄ± zamanda mÃ¼hendislerin gÃ¼Ã§lÃ¼ katÄ±lÄ±mÄ±nÄ± da gerektirir. Bu katÄ±lÄ±m, iyi geliÅŸtirilmiÅŸ ve sÃ¼rdÃ¼rÃ¼lebilir bir yazÄ±lÄ±m Ã¼rÃ¼nÃ¼ oluÅŸturmanÄ±z iÃ§in hayati Ã¶nemdedir.

Ä°nsanlarÄ±n â€œiyiâ€ kodu tanÄ±mlamak iÃ§in birÃ§ok yolu vardÄ±r. Ben iyi geliÅŸtirilmiÅŸ yazÄ±lÄ±mÄ± â€œperformantâ€ (etkin performans gÃ¶steren) olarak tanÄ±mlarÄ±m; yani yazÄ±lÄ±mÄ±nÄ±zÄ±n ihtiyaÃ§ duyduÄŸunuz dÃ¼zeyde ve biÃ§imde Ã§alÄ±ÅŸabilmesidir. Bu tanÄ±m kasÄ±tlÄ± olarak belirsizdir Ã§Ã¼nkÃ¼ bÃ¼yÃ¼k Ã¶lÃ§Ã¼de Ã¼rÃ¼nÃ¼nÃ¼ze ve kullanÄ±cÄ±ya baÄŸlÄ±dÄ±r. Performant, uygulamanÄ±zÄ±n yanÄ±t verme hÄ±zÄ± ve kullanÄ±cÄ±ya sunduÄŸu deneyim anlamÄ±na gelebilir. AynÄ± zamanda veri gÃ¼venilirliÄŸi ve eriÅŸilebilirliÄŸi anlamÄ±na da gelebilir.

Ã–rneÄŸin, mÃ¼ÅŸteri verilerinizin her an doÄŸru ve eriÅŸilebilir olup olmadÄ±ÄŸÄ±nÄ± dÃ¼ÅŸÃ¼nÃ¼n. â€œPerformantâ€ kodun sizin, ekibinizin ve mÃ¼ÅŸterilerinizin gÃ¶zÃ¼nde ne anlama geldiÄŸini Ã¶nceden dÃ¼ÅŸÃ¼nÃ¼n. YazÄ±lÄ±mÄ±nÄ±zÄ± belirli performans ihtiyaÃ§larÄ±na gÃ¶re nasÄ±l tasarlayabilirsiniz?

Geleneksel mÃ¼hendislik ekiplerinde, geliÅŸtiriciler (yani kodu yazanlar), operasyon uzmanlarÄ±ndan ayrÄ± tutulurdu. Operasyon uzmanlarÄ±, uygulamayÄ± Ã§alÄ±ÅŸtÄ±rmak ve altyapÄ±sÄ±nÄ± korumaktan sorumlu kiÅŸilerdi. Bu ayrÄ±m, insanlarÄ±n â€œKarÄ±ÅŸÄ±klÄ±k DuvarÄ± (Wall of Confusion)â€ dediÄŸi, geliÅŸtiricilerin kodu yazÄ±p operasyon ekibine fÄ±rlattÄ±ÄŸÄ± metaforik bir duvara neden oldu.

Pek Ã§ok organizasyon kendilerini Agile ya da DevOps olarak tanÄ±mlasalar bile hala bu ÅŸekilde Ã§alÄ±ÅŸÄ±yor. Ä°ÅŸ ekipleri, pazardaki ihtiyaÃ§lara karar veriyor; satÄ±ÅŸ ekipleri mÃ¼ÅŸteri isteklerini (ya da verilen vaatleri) aktarÄ±yor; Ã¼rÃ¼n yÃ¶neticileri ise tasarÄ±mÄ± yapÄ±yor ve yalnÄ±zca uygulama kÄ±smÄ± iÃ§in mÃ¼hendislik ekibine devrediyor.

Bu tÃ¼r bir iÅŸ akÄ±ÅŸÄ±, DevOpsâ€™un tam tersidir (anti-pattern) ve kesinlikle iÅŸe yaramaz. MÃ¼hendisler kod makinesi deÄŸildir. GÃ¶revleri haftalÄ±k 40 saatlik kod Ã¼retmek deÄŸil, uzmanlÄ±klarÄ± ile katkÄ± saÄŸlamaktÄ±r. OnlarÄ± sÃ¼rece dahil etmezseniz, sÃ¼rdÃ¼rÃ¼lebilir bir yazÄ±lÄ±m Ã¼rÃ¼nÃ¼ geliÅŸtiremezsiniz.

KODLA â†’ DERLE â†’ TEST ET â†’ YAYINLA â†’ BAKIM

Ve sÃ¼rekli deavam eden tekrarlar.

DevOps ile ekipleriniz sÃ¼rekli olarak bilgi paylaÅŸmalÄ± ve iÅŸ birliÄŸi iÃ§inde Ã§alÄ±ÅŸmalÄ±dÄ±r. Roller, iÃ§inde kalÄ±nmasÄ± gereken keskin sÄ±nÄ±rlar yerine uzmanlÄ±k alanlarÄ±nÄ± ifade eder. Ã–nceden roller birbirinden tamamen yalÄ±tÄ±lmÄ±ÅŸtÄ±; roller arasÄ±nda neredeyse hiÃ§ geÃ§iÅŸ yoktu. DevOps, bilgi paylaÅŸÄ±mÄ± ortamÄ± ve her rol ile yazÄ±lÄ±m teslim sÃ¼reci aÅŸamasÄ± arasÄ±nda sorumluluÄŸun paylaÅŸÄ±ldÄ±ÄŸÄ± bir yapÄ± oluÅŸturur. BÃ¶ylece geliÅŸtiriciler yalnÄ±zca kendi kodlarÄ± iÃ§in test yazmakla kalmaz, test mÃ¼hendisleri de uÃ§ durumlarÄ± belirlemeye veya geliÅŸtirme Ã¶nerileri sunmaya katkÄ± saÄŸlar.

Bu makalede sÃ¼reÃ§lerin her aÅŸamasÄ±nÄ± doÄŸrusal bir hat gibi ele alÄ±yorum. Bu doÄŸrusal yaklaÅŸÄ±mÄ± her faza DevOps'u nasÄ±l entegre edebileceÄŸimize dair ayrÄ±ntÄ±lÄ± inceleme yapmak iÃ§in kullanÄ±yorum.

Tahmin edilebileceÄŸi Ã¼zere, proje sahipleri bazen kaynaklarla mÃ¼mkÃ¼n olmayan fikirlerle gelirler. Ancak mÃ¼hendislerin eÄŸitimi ve deneyimi sayesinde, mÃ¼ÅŸterinizin problemlerini Ã§Ã¶zmenin en iyi yolunu hÄ±zlÄ±ca belirleyebilir, Ã¶zelliklerin karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± deÄŸerlendirebilir ve zaman ve kaynak maliyetleri hakkÄ±nda genel Ã¶nerilerde bulunabilirler.

Ä°tiraf: Bir Operasyoncu, danÄ±ÅŸman yada proje yÃ¶neticisi olarak geÃ§irdiÄŸim zaman boyunca, geliÅŸtirme sÃ¼resiyle ilgili tek bir tahminin bile doÄŸru Ã§Ä±ktÄ±ÄŸÄ±nÄ± gÃ¶rmedim. Gerekli zaman miktarÄ± her zaman bir tÃ¼r â€œbilinÃ§li tahminâ€dir.

Zaman tahminlerinin doÄŸruluÄŸu, mÃ¼hendislerin belirli bir zaman Ã§izelgesine uymasÄ± gerektiÄŸine inanmalarÄ±yla daha da karmaÅŸÄ±k hale gelir. Bu beklenti aÃ§Ä±kÃ§a dile getirilmese bile. Her zaman zaman tahminlerini iki katÄ±na Ã§Ä±kararak beklenmedik engeller ve zorluklar iÃ§in yeterli alan bÄ±rakÄ±lmasÄ±nÄ± Ã¶neririm. GÃ¼venin bana, mÃ¼ÅŸterileriniz Ã¼rÃ¼nÃ¼ altÄ± ay erken teslim ettiÄŸiniz iÃ§in ÅŸikayet etmez. Ancak altÄ± gÃ¼n bile geÃ§ teslim ederseniz, neredeyse kesinlikle mutsuz olacaklardÄ±r.

GeliÅŸtirme sÃ¼recinin ileriki aÅŸamalarÄ±nda ortaya Ã§Ä±kabilecek riskleri azaltmanÄ±n en iyi yolu, herkesin en baÅŸÄ±ndan itibaren masada olmasÄ±nÄ± saÄŸlamaktÄ±r. Bu planlama ve tasarÄ±m aÅŸamasÄ±, herkesin fikirlerini, gÃ¶rÃ¼ÅŸlerini ve endiÅŸelerini paylaÅŸma fÄ±rsatÄ± sunar. Bu bilgi toplama sÃ¼reci kaotik gÃ¶rÃ¼nebilir. Uzmanlardan oluÅŸan bir kakofoni gibi hissedilebilir ancak doÄŸru uygulandÄ±ÄŸÄ±nda genellikle daha iyi yazÄ±lÄ±ma yol aÃ§ar. YazÄ±lÄ±m tasarÄ±mÄ± sÄ±rasÄ±nda akÄ±lda tutulmasÄ± gereken Ã¼Ã§ yaklaÅŸÄ±m:

MÃ¼hendislerden ilk geri bildirimi alÄ±n. MÃ¼hendislerin her bir Ã¶zelliÄŸin ne kadar karmaÅŸÄ±k olacaÄŸÄ±nÄ± deÄŸerlendirmesine izin verin. ÃœrÃ¼n yÃ¶neticileri bu sayede mÃ¼hendislik perspektifinden fayda saÄŸlarken, mÃ¼hendisler de nelerin geliÅŸtirildiÄŸine dair erken bir fikir edinir (ve hangi teknolojilere odaklanmalarÄ± gerektiÄŸini anlarlar).

Analiz iÃ§in zaman tanÄ±yÄ±n. MÃ¼hendislik ekibinizin ajandasÄ±nda zaman ayÄ±rarak Ã¼rÃ¼n yÃ¶neticileriyle konuÅŸmalarÄ±nÄ±, Ã¶nerilen fikirleri deÄŸerlendirmelerini ve olasÄ± Ã§Ã¶zÃ¼mleri dÃ¼ÅŸÃ¼nmelerini saÄŸlayÄ±n. TÃ¼m cevaplarÄ± tek bir 3 saatlik toplantÄ±da alamayabilirsiniz. Ã‡oÄŸu zaman mÃ¼hendislerinizin toplantÄ±dan sonra biraz dÃ¼ÅŸÃ¼nmesi ve size geri dÃ¶nmesi gerekir. Onlara araÅŸtÄ±rma yapma ÅŸansÄ± verin, bÃ¶ylece size en doÄŸru ve bilgili yanÄ±tÄ± verebilirler.

TasarÄ±m iÃ§in Ã¶zel bir mÃ¼hendis ekibi gÃ¶revlendirmeyi dÃ¼ÅŸÃ¼nÃ¼n.BazÄ± ÅŸirketler, mimari ekiplerin oluÅŸturulmasÄ±nÄ± destekleyecek kadar bÃ¼yÃ¼ktÃ¼r. DevOps bakÄ±ÅŸ aÃ§Ä±sÄ±yla bu ekip, kendilerine bir grup Ã¶zellik atanÄ±p bunlarÄ± sÄ±ralayan sÄ±radan bir ekip deÄŸildir. Bunun yerine, yÃ¼ksek dÃ¼zey sistemleri tasarlama konusunda benzersiz niteliklere sahip uzman mÃ¼hendislerden oluÅŸurlar. DÃ¼ÅŸÃ¼k seviye detaylar yerine Ã¼rÃ¼nÃ¼ bir bÃ¼tÃ¼n olarak belirli yollarla etkileÅŸime giren Ã¶zelliklerden oluÅŸan bir aÄŸ gibi dÃ¼ÅŸÃ¼nÃ¼rler.

## â€œPerformantâ€ kod yazmak nedir ve neden Ã¶nemlidir?

Gelelim havalÄ± bir tabire: performant kod. Dilimize yerleÅŸen bu deyim, aslÄ±nda â€œyÃ¼ksek performanslÄ±, verimli kodâ€ anlamÄ±na geliyor. Peki neden bu kadar gÃ¼ndemde? Ã‡Ã¼nkÃ¼ kullanÄ±cÄ±lar sabÄ±rsÄ±zdÄ±r, sistemler nazlÄ±dÄ±r, bÃ¼tÃ§eler de kÄ±sÄ±tlÄ±dÄ±r. Performant kod yazmak, yazdÄ±ÄŸÄ±mÄ±z yazÄ±lÄ±mÄ±n hÄ±zlÄ± Ã§alÄ±ÅŸmasÄ±, kaynaklarÄ± gereksiz yere sÃ¶mÃ¼rmemesi ve Ã¶lÃ§eklenebilir olmasÄ± demektir. EÄŸer kodunuz bir kaplumbaÄŸa hÄ±zÄ±yla Ã§alÄ±ÅŸÄ±yorsa ğŸ¢, kullanÄ±cÄ±lar Ã§oktan rakip Ã¼rÃ¼ne geÃ§miÅŸ olabilir; veya kodunuz kaynaklarÄ± hoyratÃ§a kullanÄ±yorsa, bulut faturanÄ±z CIOâ€™nuzu aÄŸlatabilir.

GerÃ§ek hayattan bir Ã¶rnekle Ã¶nemini vurgulayalÄ±m: Amazonâ€™un yaptÄ±ÄŸÄ± bir araÅŸtÄ±rmaya gÃ¶re, sayfa yÃ¼kleme sÃ¼resine eklenen her 100 milisaniye gecikme satÄ±ÅŸlarÄ± %1 oranÄ±nda dÃ¼ÅŸÃ¼rebiliyormuÅŸ. DÃ¼ÅŸÃ¼nÃ¼n, sadece bir gÃ¶z kÄ±rpma sÃ¼resinde mÃ¼ÅŸterilerinizi kaybedebilirsiniz! â€œPerformantâ€ kod, iÅŸte bu yÃ¼zden altÄ±n deÄŸerinde. Hem kullanÄ±cÄ± deneyimini iyileÅŸtirir hem de sistemlerin Ã¶lÃ§eklenmesini kolaylaÅŸtÄ±rÄ±r. UnutmayalÄ±m, kodumuz Ã§alÄ±ÅŸÄ±yor olabilir ama iyi Ã§alÄ±ÅŸmasÄ± bambaÅŸka bir meziyet. Yani, kodunuz sadece iÅŸi yapmasÄ±n, bunu Formula 1 arabasÄ± gibi yapsÄ±n ğŸï¸ hÄ±zlÄ±, dengeli ve gÃ¼venilir.

DeÄŸiÅŸime uygun yazÄ±lÄ±m tasarlamak. GeliÅŸtiricilerin eski kodlarla Ã§alÄ±ÅŸmaktan nefret etmesinin nedeni, Ã¶nceki mÃ¼hendislerin kÃ¶tÃ¼ olmasÄ± deÄŸildir. GerÃ§ek ÅŸu ki bu eski kodlar, baÄŸlam ve koÅŸullar Ã§ok deÄŸiÅŸtiÄŸi iÃ§in artÄ±k iÅŸe yaramamaktadÄ±r. Bu kodlar modasÄ± geÃ§miÅŸ olabilir, ve yazÄ±lÄ±m dÃ¼nyasÄ±nda bu Ã§ok hÄ±zlÄ± olur.

DiÄŸer bazÄ± sektÃ¶rlerin aksine, yazÄ±lÄ±m geliÅŸtirme yÃ¼zlerce yÄ±ldÄ±r var olan bir alan deÄŸildir. Temel ilkeleri netleÅŸmiÅŸ bir yapÄ±ya sahip deÄŸildir. YazÄ±lÄ±m hÃ¢lÃ¢ bebeklik dÃ¶nemindedir; hÄ±zla evrilir ve geliÅŸtiriciler de bu yolculukta beraberinde sÃ¼rÃ¼klenir.

YazÄ±lÄ±mÄ±nÄ±zÄ±, deÄŸiÅŸen mÃ¼ÅŸteri ihtiyaÃ§larÄ±na uyum saÄŸlamak Ã¼zere kolayca gÃ¼ncellenebilir ÅŸekilde inÅŸa edin. Yeni ihtiyaÃ§lara hÄ±zlÄ±ca uyum saÄŸlayabilmesi iÃ§in mimarinizin esnek olmasÄ± gerekir.

DeÄŸiÅŸime uyum saÄŸlamanÄ±n yanÄ± sÄ±ra, yazÄ±lÄ±mÄ±nÄ±zÄ± yeniden kullanÄ±labilir olacak ÅŸekilde inÅŸa etmeniz de gerekir. BileÅŸen TabanlÄ± GeliÅŸtirme (Component-Based Development), birbirinden baÄŸÄ±msÄ±z, tekrar kullanÄ±labilir ve kolayca yÃ¶netilebilir bileÅŸenler geliÅŸtirmenin yoludur.

Kod zamanla deÄŸiÅŸecek olsa da, bÃ¼yÃ¼k deÄŸiÅŸikliklerin tÃ¼m sistemi etkilemesini engellemek iÃ§in mimarinizi baÅŸtan esnek ve direnÃ§li tasarlamalÄ±sÄ±nÄ±z. BaÅŸta daha fazla zaman alsa da, ilerleyen aÅŸamalarda size bÃ¼yÃ¼k hÄ±z ve esneklik kazandÄ±rÄ±r.

DeÄŸiÅŸime uyum saÄŸlamak iÃ§in sisteminizin bileÅŸenlerini aÅŸaÄŸÄ±daki Ã¶zelliklere sahip olacak ÅŸekilde tasarlayÄ±n:

  BaÄŸÄ±msÄ±z (Independent)
  Kendi kendine yeterli (Self-contained)
  Ä°yi belgelenmiÅŸ (Well-documented)
  Standartlara uygun (Standardized) â‰« TaÅŸÄ±nabilir (Portable)

Bu nitelikler sayesinde kod, baÅŸka bir yere taÅŸÄ±nabilir ya da farklÄ± donanÄ±mlar Ã¼zerinde Ã§alÄ±ÅŸabilir hÃ¢le gelir. AynÄ± zamanda kodun bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r, Ã§Ã¼nkÃ¼ yeni gelen mÃ¼hendisler kodu daha kolay anlayabilir.

## MÃ¼hendislik ekiplerinin duvarÄ±: â€œHandoffâ€ kabusu ve nasÄ±l yÄ±kÄ±lÄ±r?

Geleneksel yazÄ±lÄ±m sÃ¼reÃ§lerinde bir ekip bir iÅŸi bitirir, topu Ã¶bÃ¼r ekibe atar, sonra arkasÄ±na bile bakmazdÄ±. Bu â€œhandoffâ€ dediÄŸimiz devir-teslim anlarÄ±, mÃ¼hendislik ekiplerinin Ã¶nÃ¼ne Ã¶rÃ¼lmÃ¼ÅŸ gÃ¶rÃ¼nmez duvarlar gibidir. GeliÅŸtirme ekibi â€œBiz kodu yazdÄ±k, hadi operasyon ekibi bunu alsÄ±n Ã§alÄ±ÅŸtÄ±rsÄ±nâ€ der, test ekibi â€œBiz onayladÄ±k, gerisi sizlikâ€ derâ€¦ SonuÃ§? KaÃ§Ä±nÄ±lmaz olarak bilgi kaybÄ±, karÅŸÄ±lÄ±klÄ± suÃ§lamalar ve bolca stres. Bu yaklaÅŸÄ±m tam bir kÃ¢bus deÄŸil de nedir? ğŸ˜±

DevOps kÃ¼ltÃ¼rÃ¼ bu kabusa uyanmanÄ±n alarmÄ±dÄ±r adeta. â€œBenim iÅŸim kodu yazmak, gerisi opsâ€™un sorunuâ€ devri kapanmÄ±ÅŸtÄ±rtr. ArtÄ±k ekipler arasÄ±nda duvarlar deÄŸil, kÃ¶prÃ¼ler inÅŸa ediyoruz. GeliÅŸtirici, tester, operasyon, herkes Ã¼rÃ¼nÃ¼n baÅŸarÄ±sÄ±ndan ortak sorumluluk alÄ±r. Handoff kabusunu yenmenin ilk adÄ±mÄ±, ekibi tek bir Ã¼rÃ¼n takÄ±mÄ± olarak dÃ¼ÅŸÃ¼nmektir. Herkes sÃ¼rece daha en baÅŸÄ±ndan dahil olursa, kimse kimseye bir iÅŸi â€œatmÄ±yorâ€, birlikte yÃ¼rÃ¼tÃ¼yor demektir. Daha Ã¶nceki makalelerimde de sÃ¶ylediÄŸim gibi eÄŸer herkes sadece kendi bÃ¶lÃ¼mÃ¼ndeki iÅŸi yapÄ±p sonra paslarsa, bu yeni siloâ€™lar yaratÄ±r; oysa amaÃ§ tam tersidir. Bu duvarlarÄ± yÄ±kmak iÃ§in yapabileceÄŸiniz ÅŸeyler belli: iletiÅŸimi artÄ±rmak, sÃ¼reÃ§leri ÅŸeffaflaÅŸtÄ±rmak, ortak araÃ§lar kullanmak ve mÃ¼mkÃ¼n olduÄŸunca otomasyonla iÅŸi akÄ±ÅŸkan hale getirmek. UnutmayalÄ±m, hepimiz aynÄ± gemideyiz; kaptan kÃ¶ÅŸkÃ¼nde ayrÄ±, makine dairesinde ayrÄ± hayat yok. ğŸ˜‰

YazÄ±lÄ±mÄ±nÄ±zÄ± ve sistemlerinizi sÃ¼rekli olarak geliÅŸtirmeniz gerekir. Yeni tasarÄ±mlar ve geniÅŸleyen kodlar tutarlÄ± mÄ±? Verilen bir karar mimariyle uyumlu mu? DiÄŸer servislerle aynÄ± standartlara mÄ± sahip?

Sistem bÃ¼yÃ¼dÃ¼kÃ§e ve ekip sayÄ±sÄ± arttÄ±kÃ§a, kodun farklÄ± kiÅŸilerce yazÄ±ldÄ±ÄŸÄ± belli olur. BaÅŸta bu doÄŸal gibi gelebilir ama sÃ¼rdÃ¼rÃ¼lebilir deÄŸildir.

Kod tabanÄ±nÄ±z (altyapÄ± kodlarÄ± dahil) mÃ¼mkÃ¼n olduÄŸunca tek bir kiÅŸinin yazmÄ±ÅŸ gibi gÃ¶rÃ¼nmelidir. MÃ¼kemmeliyet ulaÅŸÄ±lmaz olabilir, ama bu uÄŸruna Ã§abalamamanÄ±z gerektiÄŸi anlamÄ±na gelmez.

EditÃ¶rlerin yazÄ± yazarken belirli dil kurallarÄ±na baÄŸlÄ± kalmalarÄ± gibi, yazÄ±lÄ±m mÃ¼hendisleri de kodlarÄ±nÄ± dÃ¼zenlemek iÃ§in lint araÃ§larÄ± kullanÄ±r. Bu araÃ§lar, kod stilinde tutarlÄ±lÄ±ÄŸÄ± saÄŸlar ve ekibin temel stil kararlarÄ±nÄ± vermesine yardÄ±mcÄ± olur. BÃ¶ylece kÃ¼Ã§Ã¼k ayrÄ±ntÄ±lar Ã¶rneÄŸin her satÄ±rÄ±n sonunda noktalÄ± virgÃ¼l olup olmamasÄ± gibi otomatik hale gelir.

EÄŸer ekibiniz bir araya gelip bu kurallar Ã¼zerinde anlaÅŸamÄ±yorsa, bu bÃ¼yÃ¼k bir iÅŸ birliÄŸi sorunudur.

Linter, kÃ¼Ã§Ã¼k konular iÃ§in faydalÄ±dÄ±r. Ancak bÃ¼yÃ¼k kararlar Ã¶rneÄŸin API tasarÄ±mÄ± daha fazla Ã¶ngÃ¶rÃ¼ ve disiplin gerektirir. Kod incelemelerini (code review) yeterince gÃ¼Ã§lÃ¼ ÅŸekilde Ã¶nermeliyim. Ä°ncelemeyi yapan kiÅŸinin kÄ±demli olmasÄ± gerekmez; sadece kodu okuyarak doÄŸru sorularÄ± sorabilmelidir.

## YazÄ±lÄ±m mimarisi Ã§izerken neden tÃ¼m ekip masada olmalÄ±

MimarlarÄ±nÄ±zÄ± veya en kÄ±demli mÃ¼hendislerinizi tÃ¼m kod incelemelerine (code review) dahil edin. Bir Ã¶zelliÄŸin daha bÃ¼yÃ¼k kod tabanÄ±na entegre edilmeden Ã¶nce mimari aÃ§Ä±dan incelenmesi, mimari bÃ¼tÃ¼nlÃ¼ÄŸÃ¼n korunmasÄ±nÄ± saÄŸlar. Bu sÃ¼reÃ§ hem mimarÄ±n hem de geliÅŸtiricinin ortak bilgi paylaÅŸÄ±mÄ±ndan faydalanmasÄ±nÄ± saÄŸlar. Mimar, Ã¶zelliÄŸin nasÄ±l geliÅŸtirildiÄŸini ve hangi araÃ§larla yapÄ±ldÄ±ÄŸÄ±nÄ± Ã¶ÄŸrenir. GeliÅŸtirici ise, kodunun takÄ±m arkadaÅŸlarÄ±yla tutarlÄ± olmasÄ±nÄ± ve temiz, iyi belgelenmiÅŸ bir kod tabanÄ± oluÅŸturmayÄ± Ã¶ÄŸrenir.

BÃ¼yÃ¼k resmi Ã§izerken kÃ¼Ã§Ã¼k ayrÄ±ntÄ±larÄ± kaÃ§Ä±rmamak iÃ§in herkesi masaya davet etmek ÅŸart. YazÄ±lÄ±m mimarisi tasarlarken sadece mimar ve birkaÃ§ geliÅŸtirici kafa kafaya verirse, ortaya kÃ¢ÄŸÄ±t Ã¼stÃ¼nde harika ama gerÃ§ek dÃ¼nyada problemli bir tasarÄ±m Ã§Ä±kabilir. Neden mi? Ã‡Ã¼nkÃ¼ belki veritabanÄ± yÃ¶neticisinin â€œBu yapÄ± ileride Ã¶lÃ§eklenmezâ€ uyarÄ±sÄ±nÄ±, gÃ¼venlikÃ§inin â€œÅurada aÃ§Ä±k olabilirâ€ Ã§ekincesini, ya da ops ekibinin â€œBunu kurmak iÃ§in Ã¶zel sihir lazÄ±m mÄ±?â€ sorusunu duymadan plan yapmÄ±ÅŸ olursunuz. Sonra gerÃ§ek dÃ¼nyada bu eksikler birer birer ortaya dÃ¶kÃ¼lÃ¼r. Ä°ÅŸte bu yÃ¼zden tÃ¼m ekip masada olmalÄ± diyoruz.

Bir yazÄ±lÄ±m mimarisi Ã§izmek, bir ÅŸehir planlamak gibidir. Sadece yollarÄ± Ã§izerseniz, su tesisatÄ±nÄ± unutuverirsiniz. DevOps bakÄ±ÅŸ aÃ§Ä±sÄ±yla, mimari tartÄ±ÅŸmalarÄ±na geliÅŸtiricisinden test uzmanÄ±na, gÃ¼venlikÃ§isinden operasyoncÄ±sÄ±na kadar herkesin katÄ±lmasÄ± altÄ±n deÄŸerindedir. Herkes masada olursa, daha tasarÄ±m aÅŸamasÄ±nda â€œBu login servisini yaparÄ±z ama deploy ederken ÅŸu adÄ±mlara dikkat gerekâ€ ya da â€œÅu modÃ¼l Ã§ok trafik Ã§ekecek, altÄ±na saÄŸlam bir altyapÄ± dÃ¼ÅŸÃ¼nelimâ€ gibi hayati noktalar gÃ¼ndeme gelir. BÃ¶ylece sonradan â€œKeÅŸke X ekibiyle baÅŸta konuÅŸsaydÄ±kâ€ demeye gerek kalmaz. KÄ±sacasÄ±, mimari tasarÄ±m bir kolektif akÄ±l iÅŸidir. Herkesin fikrini alÄ±p mayaladÄ±ÄŸÄ±nÄ±zda ortaya gerÃ§ekten kabarÄ±p leziz bir Ã§Ã¶rek Ã§Ä±kar. Aksi takdirde, tek kiÅŸinin yoÄŸurduÄŸu hamur fazla tuzlu olabilir. TÃ¼m ekip masada olunca, â€œBende Ã§alÄ±ÅŸÄ±yordu, prodâ€™da niye patladÄ±?â€ dramalarÄ± da azalÄ±r, Ã§Ã¼nkÃ¼ herkes en baÅŸtan o prodâ€™un ÅŸartlarÄ±nÄ± bilir.

## Hatalar, tahminler ve kodla gelen kahinlik: SÃ¼rekli geliÅŸim kÃ¼ltÃ¼rÃ¼

YazÄ±lÄ±m dÃ¼nyasÄ±nda geleceÄŸi gÃ¶ren bir kahin yoktur, ama hepimiz bazen kahinlik yapmaya Ã§alÄ±ÅŸÄ±rÄ±z: â€œÅimdi bu kodu bÃ¶yle yazÄ±yorum ama ileride ÅŸÃ¶yle bir Ã¶zellik isterler, ben en iyisi ÅŸimdiden buna hazÄ±rlÄ±klÄ± olayÄ±mâ€ deyip kendimizi tahmin oyunlarÄ±na kaptÄ±rÄ±rÄ±z. Kimi zaman da hatalarÄ± asla yapmayacaÄŸÄ±mÄ±zÄ± varsayarÄ±z (hah, tabi ya ğŸ™ƒ). Ä°ÅŸte DevOpsâ€™un benimsediÄŸi sÃ¼rekli geliÅŸim kÃ¼ltÃ¼rÃ¼, bu kahinlik heveslerini ve â€œben asla hata yapmamâ€ kibirini bir kenara bÄ±rakmamÄ±zÄ± sÃ¶ylÃ¼yor.

SÃ¼rekli geliÅŸim kÃ¼ltÃ¼rÃ¼nde hatalar utanÄ±lacak ÅŸeyler deÄŸil, Ã¶ÄŸrenme fÄ±rsatlarÄ±dÄ±r. Bir ÅŸey productionâ€™da patladÄ± mÄ±? DÃ¼nyanÄ±n sonu deÄŸil, hemen kollar sÄ±vanÄ±r, post-mortem yapÄ±lÄ±r, kÃ¶k neden bulunur ve ders alÄ±nÄ±r. Sonra da â€œPeki biz bunu baÅŸtan nasÄ±l Ã¶nlerdik?â€ diye dÃ¼ÅŸÃ¼nÃ¼lÃ¼r. Bu kÃ¼ltÃ¼rde ekipler sÃ¼rekli iyileÅŸtirme peÅŸindedir, her dÃ¶ngÃ¼ye bir Ã¶nceki dÃ¶ngÃ¼nÃ¼n dersleriyle girer. Yani bir nevi, yazdÄ±ÄŸÄ±mÄ±z her kod parÃ§asÄ± bize geleceÄŸe dair kÃ¼Ã§Ã¼k ipuÃ§larÄ± verir ama asÄ±l Ã¶nemli olan, bu ipuÃ§larÄ±nÄ± deÄŸerlendirip sistemi sÃ¼rekli evrimleÅŸtirmektir. Tahminlerimizi gerÃ§ek verilerle gÃ¼ncelleriz, sÃ¼reÃ§lerimizi her seferinde biraz daha cilalarÄ±z. BÃ¶ylece ekip olarak bir sonraki sprintâ€™te dÃ¼nÃ¼n kendimizden daha akÄ±llÄ± hareket ederiz. UnutmayÄ±n, â€œfail fast, fail safeâ€ mottosu boÅŸuna ortaya Ã§Ä±kmadÄ±: HÄ±zlÄ± hata yapÄ±n ki hÄ±zlÄ± Ã¶ÄŸrenin, ama hatalarÄ±nÄ±zÄ± gÃ¼venli ortamlarda yapÄ±n ki kimseye zarar vermesin. Bu felsefeyi benimseyen ekipler, zamanla adeta kendi kendini eÄŸiten, tecrÃ¼be puanÄ±nÄ± sÃ¼rekli artÄ±ran RPG karakterleri gibi level atlÄ±yor diyebiliriz. ğŸ§™â™‚ï¸

Ä°yi belgelenmiÅŸ yazÄ±lÄ±mlar oldukÃ§a nadirdir ve bunun bir nedeni vardÄ±r: SÃ¼releriniz vardÄ±r. HayatÄ±mda belgeleri terfi ya da Ã¶dÃ¼l ile iliÅŸkilendirilmiÅŸ bir geliÅŸtirici gÃ¶rmedim. Belki de bu durum deÄŸiÅŸmelidir.

DokÃ¼mantasyonun birÃ§ok amacÄ± vardÄ±r ama yalnÄ±zca kodun ne dediÄŸini Ä°ngilizceâ€™ye Ã§evirmekle sÄ±nÄ±rlÄ± kalmamalÄ±dÄ±r. Bu konuyu GitHub Copilot makalemde detaylÄ± anlatmÄ±ÅŸtÄ±m. ArtÄ±k AI kullanmak bir ayÄ±p deÄŸil aksine kullanmamak bir zaman kaybÄ± olabilir. O yÃ¼zden bir asistan gibi angarya gibi gelen sÃ¼reÃ§lerde bu kod asistanÄ±ndan faydalanmak hem keyif hemde zaman kazandÄ±racaktÄ±r.

Tabi gereksiz yorumlar zamanla modasÄ± geÃ§miÅŸ ve kafa karÄ±ÅŸtÄ±rÄ±cÄ± hale gelebilir. Kod deÄŸiÅŸtikÃ§e belgeler de gÃ¼ncellenmelidir. Tabi dokumanlar ve yorumlarda...

Kodunuz, ona bakan geliÅŸtiriciye sadece ne yaptÄ±ÄŸÄ± deÄŸil, neden bÃ¶yle yapÄ±ldÄ±ÄŸÄ± hakkÄ±nda da bilgi verecek ÅŸekilde belgelenmelidir. Belirli bir kÄ±smÄ±n sistemin geneli iÃ§indeki yeri ne? Alternatifler nelerdi? Bu uygulama neden seÃ§ildi? Hangi gÃ¶revler hÃ¢lÃ¢ yapÄ±lmadÄ± (TODO)? Bu yazÄ±lÄ±mÄ±n teknik borcu ne kadar?

DokÃ¼mantasyon, geliÅŸtiriciden geliÅŸtiriciye (ya da gelecekteki kendinize) bilgi aktarÄ±mÄ± saÄŸlar. Bu da DevOpsâ€™un temel deÄŸerlerinden biridir.

YazÄ±lÄ±mÄ±nÄ±zÄ± deÄŸiÅŸime dayanÄ±klÄ± ve sÃ¼rdÃ¼rÃ¼lebilir bir hale getirmek iÃ§in kodu yaÅŸayan bir belge (living document) gibi dÃ¼ÅŸÃ¼nÃ¼n. Kodun ve Ã¼rÃ¼nÃ¼n zamanla nasÄ±l geliÅŸtirildiÄŸini aÃ§Ä±klayan bu belge, ekip iÃ§inde bilgi paylaÅŸÄ±mÄ±nÄ± saÄŸlar. Bu yaklaÅŸÄ±m uzun vadede daha az Ã§atÄ±ÅŸma, daha hÄ±zlÄ± dÃ¶ngÃ¼ler ve daha sÃ¼rdÃ¼rÃ¼lebilir bir yazÄ±lÄ±m saÄŸlar.

## DevOpsâ€™un YetkinliÄŸi Ä°Ã§in Kod Mimarisi

Bir mÃ¼hendis ve Ã¼rÃ¼n sahibi yeni bir Ã¼rÃ¼nÃ¼n teknik tasarÄ±mÄ±nda birlikte Ã§alÄ±ÅŸÄ±rken, mÃ¼hendis hem fonksiyonlarÄ± hem de bu fonksiyonlarÄ±n nasÄ±l etkileÅŸim kurduÄŸunu dikkate alarak mimari Ã¶neriler sunar. Projenin baÅŸÄ±nda belirlenen mimari, ileride alÄ±nacak kararlarÄ± doÄŸrudan etkiler.

Bu yapÄ± sistemi ne kadar esnek yapar? Hangi alanlara yeni ÅŸeyler eklenebilir? Mimarlar sistemin nasÄ±l yapÄ±landÄ±rÄ±lacaÄŸÄ±na, hangi Ã¶zelliklerin Ã¶ncelikli olacaÄŸÄ±na ve kodun nasÄ±l standartlaÅŸtÄ±rÄ±lacaÄŸÄ±na karar verirler. AynÄ± zamanda mÃ¼hendislik ekibinin iÅŸi nasÄ±l ele alacaÄŸÄ±nÄ± da ÅŸekillendirirler.

Genel olarak, mimarlar sistem performansÄ±nÄ± etkileyen altÄ± temel baÅŸlÄ±k Ã¼zerinde dururlar.

## GÃ¼venlikten kullanÄ±labilirliÄŸe, esneklikten Ã¶lÃ§eklenebilirliÄŸe: yazÄ±lÄ±mÄ±n altÄ± sÃ¼per gÃ¼cÃ¼

Bir yazÄ±lÄ±m Ã¼rÃ¼nÃ¼nÃ¼n sÃ¼per gÃ¼Ã§leri dendiÄŸinde aklÄ±nÄ±za belki uÃ§mak, gÃ¶rÃ¼nmez olmak gelmiyor olabilir; bizim bahsedeceÄŸimiz sÃ¼per gÃ¼Ã§ler biraz daha mÃ¼hendislik iÅŸi. DevOps perspektifinde, iyi bir yazÄ±lÄ±m tasarÄ±mÄ±nÄ±n altÄ± temel vasfÄ± vardÄ±r ki bunlar onu sÄ±radan uygulamalardan sÃ¼per kahramana dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Bir uzman makalede Ã§ok net vurgulanmÄ±ÅŸ: kullanÄ±labilirlik, gÃ¼venilirlik, Ã¶lÃ§eklenebilirlik, eriÅŸilebilirlik, test edilebilirlik ve desteklenebilirlik, tek tek yeni Ã¶zellik eklemekten daha Ã¶nemlidir. Yani kalite Ã¶zellikleri nicelikten Ã¶nde gelir. Gelin bu sÃ¼per gÃ¼Ã§lere tek tek bakalÄ±m:

  GÃ¼venlik: YazÄ±lÄ±mÄ±nÄ±z Thorâ€™un Ã§ekici kadar gÃ¼Ã§lÃ¼ olsun, eÄŸer gÃ¼venlik zafiyeti varsa bir Loki Ã§Ä±kar, bÃ¼tÃ¼n sistemi altÃ¼st eder. GÃ¼venlik en baÅŸtan dÃ¼ÅŸÃ¼nÃ¼lmeli; ÅŸifreler aÃ§Ä±kta logâ€™lara yazÄ±lmasÄ±n, veri ÅŸifreleme, gÃ¼venli kimlik doÄŸrulama... KÄ±sacasÄ±, Ã¶zelliÄŸiniz Ã§alÄ±ÅŸsa da Ã§alÄ±ÅŸmasa da gÃ¼venli olmalÄ±. DevOpsâ€™ta â€œDevSecOpsâ€ akÄ±mÄ± da gÃ¼venliÄŸin ilk gÃ¼nden ele alÄ±nmasÄ± gerektiÄŸini savunur. DevSecOps, DevOps hareketinden doÄŸmuÅŸtur ve gÃ¼venliÄŸin herkesin sorumluluÄŸu olduÄŸunu topluluÄŸa hatÄ±rlatmak iÃ§in vardÄ±r. TÄ±pkÄ± geliÅŸtiriciler ve operasyon ekiplerinin kendi gÃ¶revleri olduÄŸu gibi, gÃ¼venlik de yalnÄ±zca belirli kiÅŸilere ait bir sorumluluk deÄŸildir. GeÃ§miÅŸte gÃ¼venlik genellikle dÃ¼ÅŸmanca bir iliÅŸkiyle ele alÄ±nÄ±rdÄ± geliÅŸtirme tamamlanÄ±r, gÃ¼venlik en sonda gelip hatalarÄ± engellerdi. Ancak DevSecOps, "gÃ¼venliÄŸi sona bÄ±rakma" anlayÄ±ÅŸÄ±nÄ±n yerine "gÃ¼venliÄŸi en baÅŸtan dahil etme" fikrini savunur. Yani gÃ¼venlik, yazÄ±lÄ±m geliÅŸtirme yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼n baÅŸlarÄ±nda planlama ve tasarÄ±m sÃ¼reÃ§lerine entegre edilmelidir.
  KullanÄ±labilirlik: UygulamanÄ±zÄ±n arayÃ¼zÃ¼ ve deneyimi, sÃ¼per gÃ¼Ã§lerin sevimli devi Hulk gibidir: KarmaÅŸÄ±k olabilir ama kullanÄ±cÄ±lar iÃ§in anlaÅŸÄ±lÄ±r ve rahat olmalÄ±dÄ±r. KullanÄ±labilirlik, son kullanÄ±cÄ±ya verdiÄŸiniz deÄŸerin ilk hissedildiÄŸi yerdir. TasarÄ±m aÅŸamasÄ±nda kullanÄ±cÄ± hikÃ¢yelerini, deneyim akÄ±ÅŸlarÄ±nÄ± hesaba katmak ÅŸart. KullanÄ±labilirlik, bir kullanÄ±cÄ±nÄ±n sisteminizi ne kadar kolay kullanabildiÄŸini tanÄ±mlar. KullanÄ±labilirlik; kullanÄ±cÄ± arayÃ¼zÃ¼ (UI) ve kullanÄ±cÄ± deneyimi (UX) tasarÄ±mÄ±nÄ±n temelidir. UygulamanÄ±zla olan her etkileÅŸim bu kavram Ã¼zerinden dÃ¼ÅŸÃ¼nÃ¼lmelidir.
  Esneklik: DeÄŸiÅŸime hÄ±zlÄ± adapte olabilme yeteneÄŸi. YarÄ±n yeni bir Ã¶zellik eklemek istediÄŸinizde tÃ¼m sistemi yÄ±kÄ±p baÅŸtan kurmak zorunda kalmamak iÃ§in yazÄ±lÄ±mÄ±nÄ±z esnek olmalÄ±. ModÃ¼ler mimariler, soyutlamalar, arayÃ¼zler bu esnekliÄŸi saÄŸlar. Esnek bir tasarÄ±m, pivot etmeniz gerektiÄŸinde size kanat takar ğŸ¦‹. Esnek bir sistem, mÃ¼ÅŸterinin deÄŸiÅŸen ihtiyaÃ§larÄ±na hÄ±zlÄ±ca uyum saÄŸlayabilen sistemdir. Esnek kod tabanÄ±, bÃ¼yÃ¼k kesintilere yol aÃ§madan yeni kodlarÄ± entegre edebilir.
  Ã–lÃ§eklenebilirlik: BugÃ¼n 100 kullanÄ±cÄ±ya hizmet veren uygulama, yarÄ±n 100 bin kullanÄ±cÄ±ya Ã§Ä±karsa ne olur? Ä°ÅŸte Ã¶lÃ§eklenebilirlik bu senaryoda devreye girer. YazÄ±lÄ±mÄ±n artan yÃ¼k altÄ±nda aynÄ± performansÄ± koruyabilmesi, yatay/dikey Ã¶lÃ§ekleme yapÄ±sÄ±na uygun tasarlanmasÄ± gerekir. â€œPerformant kodâ€ yazmak da burada tekrar sahne alÄ±yor; kodunuz Ã¶lÃ§eklenmeye hazÄ±r olmalÄ±. Bir sistemin Ã¶lÃ§eklenebilirliÄŸi, yeni kaynaklar eklendiÄŸinde sistemin daha iyi performans gÃ¶sterip gÃ¶stermediÄŸiyle Ã¶lÃ§Ã¼lÃ¼r. EÄŸer gÃ¶steriyorsa, sistem Ã¶lÃ§eklenebilirdir. GÃ¶stermiyorsa, Ã¶nÃ¼nÃ¼zde uzun bir yol olabilir. UygulamanÄ±zÄ± Ã¶lÃ§eklendirmek, sÃ¼recin erken aÅŸamalarÄ±nda zor olabilir. HenÃ¼z 200 kullanÄ±cÄ±nÄ±z yoksa bile, startuplar ve yeni Ã¼rÃ¼nler iÃ§in ilk endiÅŸe genellikle Ã¶lÃ§eklenebilirlik deÄŸil, herhangi bir kullanÄ±cÄ± kazanabilmektir. Ancak bÃ¼yÃ¼meyi dÃ¼ÅŸÃ¼nerek yazÄ±lÄ±mÄ±n daha fazla kullanÄ±cÄ±ya ulaÅŸabilmesi iÃ§in ne gibi yollar izlenebilir bunu deÄŸerlendirmek iyi bir fikirdir. Yine de bÃ¼yÃ¼me hedefi, kÄ±sa vadede sizin iÃ§in en kritik olan konularÄ± gÃ¶lgelememelidir. Bulut iÃ§in tasarlanan uygulamalarÄ±n avantajlarÄ±ndan biri, esneklik (flexibility), dayanÄ±klÄ±lÄ±k (resilience) ve evet, doÄŸru tahmin ettiniz otomatikleÅŸtirilebilir ve iyileÅŸtirilebilir Ã¶lÃ§eklenebilirlik sunmasÄ±dÄ±r.
  SÃ¼rdÃ¼rÃ¼lebilirlik: YazÄ±lÄ±mÄ±nÄ±zÄ±n arÄ±za toleransÄ± ve hata karÅŸÄ±sÄ±nda saÄŸlam kalabilmesi. Bir parÃ§a Ã§Ã¶kerse tÃ¼m sistem domino taÅŸlarÄ± gibi yÄ±kÄ±lmasÄ±n. Yedeklilik, hata ayÄ±klama mekanizmalarÄ±, otomatik yeniden baÅŸlatma gibi Ã¶nlemlerle sistemin gÃ¼venilirliÄŸi saÄŸlanÄ±r. UnutmayÄ±n, kullanÄ±cÄ±lar yazÄ±lÄ±mÄ±nÄ±za gÃ¼venirse, tekrar gelir; gÃ¼venilmez bulursa kaÃ§ar. Kod deÄŸiÅŸir. Yeni Ã¶zellikler eklenmeli, eski olanlar kaldÄ±rÄ±lmalÄ± veya bakÄ±m moduna alÄ±nmalÄ±dÄ±r. Mevcut Ã¶zellikler evrim geÃ§irir. YazÄ±lÄ±m gÃ¼ncellenmelidir. DeÄŸiÅŸim kaÃ§Ä±nÄ±lmazdÄ±r ve buna hazÄ±rlÄ±klÄ± olunmalÄ±dÄ±r. YazÄ±lÄ±mÄ±nÄ±zÄ±n sÃ¼rdÃ¼rÃ¼lebilirliÄŸi, deÄŸiÅŸim karÅŸÄ±sÄ±ndaki direnci ile doÄŸrudan iliÅŸkilidir. Kodunuz kapsamlÄ± bir otomatik test sÃ¼iti ile test edilmelidir. Manuel testler bir yere kadar gÃ¶tÃ¼rÃ¼r. Modern sistemler Ã§ok karmaÅŸÄ±ktÄ±r; iki kiÅŸi ekrana bakarak â€œher ÅŸey yolunda mÄ±?â€ diyemez. Kodun, kabul kriterlerini karÅŸÄ±ladÄ±ÄŸÄ±ndan emin olmanÄ±z gerekir. Yani, bir Ã¶zelliÄŸin gerÃ§ekten Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± nasÄ±l anlarsÄ±nÄ±z? UÃ§ senaryolarÄ± da test etmelisiniz. Hayal edebilirsiniz: Bir dizi parametre olarak girildiÄŸinde ne olur ama kod bir hash bekliyordur? Ya e-posta adresinde @ iÅŸareti eksikse? Her hata dÃ¼zeltildiÄŸinde, o hatanÄ±n gerÃ§ekten Ã§Ã¶zÃ¼ldÃ¼ÄŸÃ¼nden emin olmak iÃ§in yeni bir test eklemelisiniz. Bu testler size, yeni kodun mevcut Ã¶zellikleri bozup bozmadÄ±ÄŸÄ±nÄ± kullanÄ±cÄ±lar etkilenmeden Ã¶nce bildirir. Kodunuzu belgelemeniz gerekir. Belgeleme, neredeyse tÃ¼m mÃ¼hendislik ekiplerinin zorlandÄ±ÄŸÄ± bir ÅŸeydir. Ã‡Ã¼nkÃ¼ genellikle belgeyle deÄŸerlendirilmezler. Onlardan beklenen, sadece Ã¶zelliÄŸi tamamlamak ya da bir hatayÄ± dÃ¼zeltmektir. Ancak bu Ã¶lÃ§Ã¼m, uzun vadede yeterli deÄŸildir. Bu durumu iyileÅŸtirmek iÃ§in kod incelemelerine belgeleme kriteri de ekleyin. Karar matrisini ve geliÅŸtiricinin yaptÄ±ÄŸÄ± tercihlerde neleri dikkate aldÄ±ÄŸÄ±nÄ± belgeleyin. Hangi alternatifler dÃ¼ÅŸÃ¼nÃ¼ldÃ¼? Neden bu Ã§Ã¶zÃ¼m seÃ§ildi? Bu baÄŸlam, daha sonra (Ã¶zellikle kodu ilk yazan kiÅŸi artÄ±k ekipte deÄŸilse) bÃ¼yÃ¼k deÄŸer taÅŸÄ±r. Ve unutmayÄ±n: kod deÄŸiÅŸirse, testler ve belgeler de deÄŸiÅŸmelidir.
  Test Edilebilirlik: SÃ¼per gÃ¼Ã§lerin belki de en gizli kahramanÄ±. Kodunuz ne kadar test edilebilir ise o kadar hÄ±zlÄ± geliÅŸtirme yapabilirsiniz. Otomasyon testleri, birim testleri, entegrasyon testleri tasarÄ±mÄ±nÄ±zÄ±n ayrÄ±lmaz bir parÃ§asÄ± olmalÄ±. Test edilebilir bir tasarÄ±m, sÃ¼rekli entegrasyon ve sÃ¼rekli teslimat (CI/CD) hattÄ±nda size Ä±ÅŸÄ±k hÄ±zÄ± kazandÄ±rÄ±r. Testleri geÃ§emeyen kod Ã¼retime Ã§Ä±kamaz; bu da kaliteyi gÃ¼vence altÄ±na alÄ±r.

Bu altÄ± sÃ¼per gÃ¼Ã§, Ã¶zÃ¼nde yazÄ±lÄ±mÄ±n niteliÄŸini belirler. Ã–zellik tasarlarken bu gÃ¼Ã§leri gÃ¶z ardÄ± etmek, sÃ¼per kahramanÄ± pelerininden mahrum bÄ±rakmaya benzer. SonuÃ§ta uÃ§ar ama rÃ¼zgar alÄ±r, Ã¼ÅŸÃ¼tÃ¼r ğŸ˜Š. Ä°ÅŸin ÅŸakasÄ± bir yana, DevOps yaklaÅŸÄ±mÄ± bu kalite Ã¶zelliklerini en baÅŸtan gÃ¶zetmeyi Ã¶ÄŸÃ¼tler. Ã‡Ã¼nkÃ¼ sonradan eklemeye kalkmak ya Ã§ok pahalÄ±ya patlar ya da imkÃ¢nsÄ±z hale gelir.

## Geldik bu bÃ¶lÃ¼mÃ¼n finaline...

Buraya kadar okuduysanÄ±z muhtemelen kafanÄ±zda ÅŸÃ¶yle bir soru var: â€œÄ°yi hoÅŸ, bÃ¼tÃ¼n bunlarÄ± yapacaÄŸÄ±z da, bunlarÄ± uygulamak emek istemiyor mu?â€ Elbette istiyor. Bu noktada kÃ¼Ã§Ã¼k bir sitemimi de iletmeden geÃ§emeyeceÄŸim: KodlarÄ±na tek bir yorum satÄ±rÄ± bile eklemeyen geliÅŸtiriciler, lÃ¼tfen bunu bir daha dÃ¼ÅŸÃ¼nÃ¼n ğŸ™. Ã‡Ã¼nkÃ¼ yazdÄ±ÄŸÄ±nÄ±z kodu bir ay sonra siz bile anlamakta zorlanÄ±yorsanÄ±z, ekip arkadaÅŸlarÄ±nÄ±z ne yapsÄ±n? Ä°yi bir dÃ¶kÃ¼mantasyon ve yorum alÄ±ÅŸkanlÄ±ÄŸÄ±, DevOpsâ€™un bilgi paylaÅŸÄ±mÄ± ruhuna en yakÄ±ÅŸan davranÄ±ÅŸlardan biridir. UnutmayÄ±n, kod insana da hitap eder, sadece makineye deÄŸil.

Ve gelelim teÅŸekkÃ¼re: YazÄ±lÄ±m mimarlarÄ± ve ekip liderleri, sizlere kocaman bir alkÄ±ÅŸ ğŸ‘. Neden mi? Ã‡Ã¼nkÃ¼ bu DevOps prensiplerini hayata geÃ§irmek genelde sizin omuzlarÄ±nÄ±za bakÄ±yor. Ekipleri bir araya getirmek, herkesi aynÄ± vizyona ikna etmek, tasarÄ±mÄ±n her boyutunu dÃ¼ÅŸÃ¼nmekâ€¦ Kolay iÅŸler deÄŸil. Ä°yi bir mimar, bir orkestra ÅŸefi gibi tÃ¼m enstrÃ¼manlarÄ±n uyum iÃ§inde Ã§almasÄ±nÄ± saÄŸlar. Biz geliÅŸtiriciler belki sahnede solo atÄ±yoruz ama arka planda o senfoniyi yazan mimarlara mÃ¼teÅŸekkiriz.

Son sÃ¶z: YazÄ±lÄ±m tasarÄ±mÄ± bir yolculuk ve bu yolculukta DevOps prensipleri hem haritamÄ±z hem pusulamÄ±z. Kod yazmak elbette iÅŸimizin Ã¶zÃ¼, ama etrafÄ±na Ã¶rdÃ¼ÄŸÃ¼mÃ¼z sÃ¼reÃ§ler, ekip kÃ¼ltÃ¼rÃ¼ ve tasarÄ±m kararlarÄ± olmadan o kod ne kadar parlayabilir ki? Hem eÄŸlenceli hem Ã¶ÄŸretici olmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z bu yazÄ±da, umarÄ±m sizi biraz gÃ¼lÃ¼msetirken dÃ¼ÅŸÃ¼ndÃ¼rebilmiÅŸizdir. Åimdi gidip kodunuza bir yorum satÄ±rÄ± ekleyin veya bir takÄ±m arkadaÅŸÄ±nÄ±za teÅŸekkÃ¼r edin derim. Happy DevOps ve bol kahkahalÄ± kodlamalar! ğŸ‰
